{
  config,
  lib,
  pkgs,
  ...
}:
with lib;
let
  cfg = config.modules.services.docker-cache;

  # Pre-pulled image for deterministic builds
  registryProxyImage = pkgs.dockerTools.pullImage {
    imageName = "rpardini/docker-registry-proxy";
    imageDigest = "sha256:b70b2ef2371171a630e3fcbf2217e04057c1dbe114fa46d332ebde67349869e9";
    sha256 = "sha256-sjia/lObfK9+PuZcD03EczWIcv/ldv44sGUR9w1ZkIE=";
    finalImageName = "rpardini/docker-registry-proxy";
    finalImageTag = "0.6.5";
  };
in
{
  options.modules.services.docker-cache = {
    enable = mkEnableOption "Docker registry cache proxy";

    cacheDir = mkOption {
      type = types.str;
      default = "/var/cache/docker-registry-proxy";
      description = "Directory to store cached Docker layers";
    };

    domain = mkOption {
      type = types.str;
      description = "Domain name for the Docker cache proxy";
    };

    acmeHost = mkOption {
      type = types.str;
      description = "ACME host for SSL certificates";
    };

    maxSize = mkOption {
      type = types.str;
      default = "100g";
      description = "Maximum size of the cache (e.g., '100g', '500g')";
    };

    port = mkOption {
      type = types.port;
      default = 3128;
      description = "Port for the Docker registry proxy";
    };

    registries = mkOption {
      type = types.listOf types.str;
      default = [
        "docker.io"
        "gcr.io"
        "k8s.gcr.io"
        "quay.io"
        "ghcr.io"
      ];
      description = "List of registries to proxy and cache";
    };

    authConfigFile = mkOption {
      type = types.nullOr types.path;
      default = null;
      description = ''
        Path to authentication configuration file.

        Expected file format (one line per registry):
        REGISTRY_NAME:USERNAME:PASSWORD

        Example:
        docker.io:myusername:mypassword
      '';
    };

    containerHostname = mkOption {
      type = types.str;
      default = "docker-registry-proxy";
      description = "Hostname for the docker-registry-proxy container";
    };

    enableSSL = mkOption {
      type = types.bool;
      default = true;
      description = "Enable SSL for the cache proxy";
    };
  };

  config = mkIf cfg.enable {
    assertions = [
      {
        assertion = cfg.domain != "";
        message = "modules.services.docker-cache: domain must be set";
      }
      {
        assertion = !cfg.enableSSL || cfg.acmeHost != "";
        message = "modules.services.docker-cache: acmeHost must be set when SSL is enabled";
      }
    ];

    # Create cache directories
    systemd.tmpfiles.rules = [
      "d ${cfg.cacheDir} 0755 root root -"
      "d ${cfg.cacheDir}/cache 0755 root root -"
      "d ${cfg.cacheDir}/ca 0755 root root -"
    ];

    # Export CA certificate for clients to use
    systemd.services.docker-registry-proxy-ca-export = {
      description = "Export Docker Registry Proxy CA Certificate for clients";
      after = [ "docker-docker-registry-proxy.service" ];
      wants = [ "docker-docker-registry-proxy.service" ];
      unitConfig = {
        After = mkForce [
          "docker-docker-registry-proxy.service"
          "docker-registry-proxy.service"
        ];
        Wants = mkForce [
          "docker-docker-registry-proxy.service"
          "docker-registry-proxy.service"
        ];
      };
      serviceConfig = {
        Type = "oneshot";
        RemainAfterExit = true;
        Restart = "on-failure";
        RestartSec = "5s";
        ExecStart = pkgs.writeScript "export-ca" ''
          #!${pkgs.bash}/bin/bash
          set -e

          # Wait for docker container to be running
          timeout=60
          while [ $timeout -gt 0 ] && ! ${pkgs.docker}/bin/docker ps | grep -q docker-registry-proxy; do
            echo "Waiting for docker-registry-proxy container to start..."
            sleep 1
            timeout=$((timeout - 1))
          done

          # Wait for CA certificate to be generated by the container
          timeout=60
          while [ $timeout -gt 0 ] && [ ! -f "${cfg.cacheDir}/ca/ca.crt" ]; do
            echo "Waiting for CA certificate to be generated..."
            sleep 1
            timeout=$((timeout - 1))
          done

          if [ -f "${cfg.cacheDir}/ca/ca.crt" ]; then
            # Make CA cert accessible via nginx for clients to download
            mkdir -p /var/lib/nginx/docker-registry-proxy
            cp "${cfg.cacheDir}/ca/ca.crt" /var/lib/nginx/docker-registry-proxy/ca.crt
            chmod 644 /var/lib/nginx/docker-registry-proxy/ca.crt
            chown nginx:nginx /var/lib/nginx/docker-registry-proxy/ca.crt
            echo "CA certificate exported for client download"
          else
            echo "ERROR: Failed to find CA certificate at ${cfg.cacheDir}/ca/ca.crt"
            exit 1
          fi
        '';
      };
      wantedBy = [ "multi-user.target" ];
    };

    virtualisation.oci-containers = {
      backend = "docker";
      containers.docker-registry-proxy = {
        image = "rpardini/docker-registry-proxy:0.6.5";
        imageFile = registryProxyImage;
        hostname = cfg.containerHostname;
        extraOptions = [
          "--add-host=${cfg.containerHostname}:127.0.0.1"
        ];
        ports = [
          "${toString cfg.port}:3128"
        ];
        volumes = [
          "${cfg.cacheDir}/cache:/docker_mirror_cache"
          "${cfg.cacheDir}/ca:/ca"
        ] ++ optionals (cfg.authConfigFile != null) [
          "${cfg.authConfigFile}:/auth.conf:ro"
        ];
        environment = {
          ENABLE_MANIFEST_CACHE = "true";
          REGISTRIES = concatStringsSep " " cfg.registries;
          CACHE_MAX_SIZE = cfg.maxSize;
          DEBUG = "false";
          DEBUG_NGINX = "false";
          PROXY_REQUEST_BUFFERING = "false";
          VERIFY_SSL = "true";
        } // optionalAttrs (cfg.authConfigFile != null) {
          AUTH_CONFIG_FILE = "/auth.conf";
        };
      };
    };

    # Override the systemd service to ensure image is loaded before starting
    systemd.services."docker-docker-registry-proxy" = {
      preStart = mkBefore ''
        if ! ${pkgs.docker}/bin/docker image inspect "rpardini/docker-registry-proxy:0.6.5" &>/dev/null; then
          echo "Loading docker-registry-proxy image from Nix store..."
          ${pkgs.docker}/bin/docker load < ${registryProxyImage}
        fi
      '';
    };

    # Configure nginx to proxy directly to the rpardini container
    services.nginx = {
      enable = mkDefault true;

      virtualHosts.${cfg.domain} = {
        forceSSL = mkDefault cfg.enableSSL;
        useACMEHost = mkIf cfg.enableSSL (mkDefault cfg.acmeHost);

        # Serve CA certificate
        locations."/ca.crt" = {
          root = "/var/lib/nginx/docker-registry-proxy";
          extraConfig = ''
            add_header Content-Type application/x-x509-ca-cert;
            add_header Content-Disposition 'attachment; filename="docker-registry-proxy-ca.crt"';
          '';
        };

        # Proxy all other traffic to rpardini container
        locations."/" = {
          proxyPass = "http://127.0.0.1:${toString cfg.port}";
          extraConfig = ''
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;

            client_max_body_size 0;
            proxy_request_buffering off;
            proxy_buffering off;

            proxy_read_timeout 900;
            proxy_connect_timeout 60;
            proxy_send_timeout 900;

            proxy_http_version 1.1;
            proxy_set_header Connection "";
          '';
        };
      };
    };
  };
}
